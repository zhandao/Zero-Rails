module ModelDocSupport
  module Helpers
    def inherited(base)
      super
      base.class_eval do
        cattr_accessor :model_name, :model_rb_stack, :migration_rb_stack, :migration_indexes, :builder_rmv
        cattr_accessor :fields, :scopes, :imethods, :cmethods

        self.model_name = name.sub('Mdoc', '')
        self.model_rb_stack = [ ]
        model_rb_stack.push ''
        self.migration_rb_stack = [ ]
        migration_rb_stack.push ''
        self.fields = { }
        self.migration_indexes = [ ]
        self.builder_rmv = [ ]

        self.path = "models/#{model_name.underscore}"
      end
    end

    def process_and_returns_options(name, type, req, options)
      if options.delete(:show)
        builder_rmv << name
      end
      options
    end

    def run
      Dir['./app/**/*_mdoc.rb'].each { |file| require file }
      descendants.each do |mdoc|
        model_file_name = mdoc.model_name.underscore
        model_path = "app/models/#{model_file_name}.rb"
        # if Config.overwrite_files || !File::exist?(model_path)
        if true
          File.open(model_path, 'w') { |file| file.write mdoc.model_rb.sub("\n\n\nend\n", "\nend\n") }
          puts "[Zero] Model file has been generated: #{model_path}"
        end

        mg_next_version = ::ActiveRecord::Migration.next_migration_number(::ActiveRecord::Migrator.current_version)
        mg_file_name = "#{mg_next_version}_create_#{mdoc.model_name.underscore.pluralize}"
        mg_path = "db/migrate/#{mg_file_name}.rb"
        # if Config.overwrite_files || !File::exist?(mg_path)
        if true
          File.open(mg_path, 'w') { |file| file.write mdoc.migration_rb.sub("\n\n\nend\n", "\nend\n") }
          puts "[Zero] Migration file has been generated: #{mg_path}"
        end
      end
    end

    def fields_to_migration
      _t = fields.delete(:deleted_at)
      fields[:deleted_at] = _t unless _t.nil?
      type_max_length = fields.values.map(&:first).map(&:length).sort.last
      name_max_length = fields.keys.map(&:length).sort.last
      key_order = %i[ foreign_key polymorphic null default index ] # TODO

      fields.each do |name, info|
        type = info.shift.to_s.ljust(type_max_length)
        info = info.reduce({ }, :merge)
        if info.delete(:unique)
          migration_indexes << name
          info.delete(:index)
        end

        info = key_order.map { |key| { key => info[key] } if info.key?(key) }.compact.reduce({ }, :merge)
        params = info.present? ? "#{name},".ljust(name_max_length + 2) << pr(info) : name.to_s

        migration_rb_stack.last << <<~FIELD
          t.#{type} :#{params}
        FIELD
      end
    end

    def indexes_to_migration
      return nil if migration_indexes.blank?
      "\n" << migration_indexes.map do |name|
        <<~INDEX
          add_index :#{model_name.underscore.pluralize}, :#{name}, unique: true
        INDEX
      end.join
    end

    def model_rb
      <<~MODEL
        # *** Generated by Zero [ please make sure that you have checked this file ] ***

        class #{model_name} < ApplicationRecord
          #{add_ind_to model_rb_stack.last}
        end
      MODEL
    end

    def migration_rb
      fields_to_migration

      <<~MG
        # *** Generated by Zero [ please make sure that you have checked this file ] ***

        class Create#{model_name.pluralize} < ActiveRecord::Migration[5.1]
          def change
            create_table :#{model_name.underscore.pluralize}, options: 'ROW_FORMAT=DYNAMIC DEFAULT CHARSET=utf8' do |t|
              #{add_ind_to migration_rb_stack.last, 3}
              t.timestamps
            end
            #{add_ind_to indexes_to_migration, 2}
          end
        end
      MG
    end
  end
end
